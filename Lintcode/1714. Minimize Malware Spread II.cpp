class Solution {
public:
    int minMalwareSpread(vector<vector<int>> &graph, vector<int> &initial) {
       init();
       
       const int n = graph.size();
       unordered_set<int> initial_set(initial.begin(), initial.end());
       
       for (int u = 0; u < n; u++) {
           if (initial_set.count(u)) continue;
           
           for (int v = u + 1; v < n; v++) {
               if (initial_set.count(v)) continue;
               
               merge(u, v);
           }
       }
       
       vector<int> refs(n + 1, 0);
       for (int u : initial_set) {
           unordered_set<int> p;
           for (int v = 0; v < n; v++) {
               if (u == v || initial_set.count(v) || !graph[u][v]) continue;
               
               const int pv = findParent(v);
               p.insert(pv);
           }

           for (auto& v : p) refs[v]++;
       }
       
       int ans = 9999999, ans_size = 0;
       for (int u : initial_set) {
           unordered_set<int> visited;
           int tmp = 0;
           
           for (int v = 0; v < n; v++) {
               if (u == v || initial_set.count(v) || !graph[u][v]) continue;
               
               const int pv = findParent(v);
               

               if (!visited.count(pv) && refs[pv] == 1) {
                   visited.insert(pv);
                   tmp += size[pv];
               }

           }

            if (tmp > ans_size || (tmp == ans_size && u < ans)) {
                ans = u;
                ans_size = tmp;
            }
       }
       return ans;
    }
private:
    int parent[305], size[305];
    void init() {
        for (int i = 0; i <= 300; i++) {
            parent[i] = i;
            size[i] = 1;
        }
    }
    int findParent(int u) {
        if (parent[u] == u) return u;
        else return parent[u] = findParent(parent[u]);
    }
    void merge(int u, int v) {
        const int pu = findParent(u), pv = findParent(v);
        if (parent[pu] != pv) {
            parent[pu] = pv;
            size[pv] += size[pu];
        }
    }
};
